import logging
from typing import Optional, Dict, Any
import asyncio
from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from aiogram.filters import CommandStart, Command
from aiogram.fsm.storage.memory import MemoryStorage

from app.core.config import get_settings
from app.services.redis_service import redis_service

logger = logging.getLogger(__name__)


class TelegramService:
    """Simplified Telegram service for OTP and order notifications"""
    
    def __init__(self):
        self.bot = None
        self.dp = None
        self.router = None
        self._initialized = False
        
    async def initialize(self, token: str = None):
        """Initialize Telegram bot with token"""
        if self._initialized:
            return
            
        settings = get_settings()
        bot_token = token or getattr(settings, 'TELEGRAM_BOT_TOKEN', None)
        
        if not bot_token:
            logger.error("Telegram bot token not provided")
            return
        
        try:
            self.bot = Bot(token=bot_token)
            
            # Initialize dispatcher with memory storage
            storage = MemoryStorage()
            self.dp = Dispatcher(storage=storage)
            
            # Create router for handlers
            self.router = Router()
            
            # Register handlers
            self._register_handlers()
            
            # Include router in dispatcher
            self.dp.include_router(self.router)
            
            # Verify bot token
            bot_info = await self.bot.get_me()
            logger.info(f"Telegram bot initialized: @{bot_info.username}")
            
            self._initialized = True
        except Exception as e:
            logger.error(f"Failed to initialize Telegram bot: {e}")
            raise
    
    async def send_otp(self, telegram_id: int, otp_code: str) -> bool:
        """Send OTP to specific Telegram user"""
        if not self._initialized:
            logger.error("Telegram bot not initialized")
            return False
        
        try:
            message = (
                f"üîê **–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–ª—è –≤—Ö–æ–¥–∞ –≤ CRM:**\n\n"
                f"**{otp_code}**\n\n"
                "–í–≤–µ–¥–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –Ω–∞ —Å–∞–π—Ç–µ.\n"
                "‚è± –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç."
            )
            
            await self.bot.send_message(
                chat_id=telegram_id,
                text=message,
                parse_mode="Markdown"
            )
            
            return True
        except Exception as e:
            logger.error(f"Failed to send OTP to Telegram user {telegram_id}: {e}")
            return False
    async def send_order_notification(self, telegram_id: int, order_info: dict) -> bool:
        """Send order notification to Telegram user"""
        if not self._initialized:
            logger.error("Telegram bot not initialized")
            return False
        
        try:
            message = (
                f"üì¶ **–ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #{order_info.get('id')}**\n\n"
                f"üí∞ –°—É–º–º–∞: {order_info.get('total', 0):,} ‚Ç∏\n"
                f"üë§ –ö–ª–∏–µ–Ω—Ç: {order_info.get('customer_name', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n"
                f"üìû –¢–µ–ª–µ—Ñ–æ–Ω: {order_info.get('customer_phone', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n"
                f"üìç –ê–¥—Ä–µ—Å: {order_info.get('delivery_address', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n\n"
                f"‚è∞ –í—Ä–µ–º—è –∑–∞–∫–∞–∑–∞: {order_info.get('created_at', '')}\n\n"
                "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–∞–∫–∞–∑ –≤ CRM —Å–∏—Å—Ç–µ–º–µ!"
            )
            
            await self.bot.send_message(
                chat_id=telegram_id,
                text=message,
                parse_mode="Markdown"
            )
            
            return True
        except Exception as e:
            logger.error(f"Failed to send order notification to Telegram user {telegram_id}: {e}")
            return False
    async def send_notification(self, telegram_id: int, text: str) -> bool:
        """Send notification to Telegram user"""
        if not self._initialized:
            logger.error("Telegram bot not initialized")
            return False
        
        try:
            await self.bot.send_message(chat_id=telegram_id, text=text)
            return True
        except Exception as e:
            logger.error(f"Failed to send notification to Telegram user {telegram_id}: {e}")
            return False
    
    async def start_polling(self):
        """Start polling (placeholder method - not implemented for simple service)"""
        logger.info("Telegram polling mode not implemented in this service")
        # This is a placeholder method since we're only using webhook/direct sending
        pass
    
    async def setup_webhook(self, webhook_url: str, webhook_path: str = "/api/telegram/webhook"):
        """Setup webhook for production"""
        if not self._initialized:
            logger.error("Bot not initialized")
            return
        
        try:
            full_webhook_url = f"{webhook_url.rstrip('/')}{webhook_path}"
            await self.bot.set_webhook(url=full_webhook_url)
            logger.info(f"Webhook set to: {full_webhook_url}")
        except Exception as e:
            logger.error(f"Failed to set webhook: {e}")
            raise

    def _register_handlers(self):
        """Register message handlers"""
        @self.router.message(CommandStart())
        async def start_handler(message: Message):
            """Handle /start command"""
            user_name = message.from_user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
            
            welcome_text = (
                f"üëã –ü—Ä–∏–≤–µ—Ç, {user_name}!\n\n"
                "üîê –Ø –ø–æ–º–æ–≥–∞—é —Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π –∏ –æ—Ç–ø—Ä–∞–≤–ª—è—é –∫–æ–¥—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n\n"
                "üì± **–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥:**\n"
                "1. –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å–≤–æ–∏–º –∫–æ–Ω—Ç–∞–∫—Ç–æ–º (–∫–Ω–æ–ø–∫–∞ –Ω–∏–∂–µ)\n"
                "2. –í–≤–µ–¥–∏—Ç–µ —Ç–æ—Ç –∂–µ –Ω–æ–º–µ—Ä –Ω–∞ —Å–∞–π—Ç–µ\n"
                "3. –ù–∞–∂–º–∏—Ç–µ ¬´–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥¬ª –Ω–∞ —Å–∞–π—Ç–µ\n"
                "4. –ü–æ–ª—É—á–∏—Ç–µ –∫–æ–¥ –≤ —ç—Ç–æ–º —á–∞—Ç–µ\n\n"
                "üëá –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –∫–æ–Ω—Ç–∞–∫—Ç–æ–º"
            )
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –∑–∞–ø—Ä–æ—Å–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞
            contact_button = KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –∫–æ–Ω—Ç–∞–∫—Ç–æ–º", request_contact=True)
            keyboard = ReplyKeyboardMarkup(
                keyboard=[[contact_button]],
                resize_keyboard=True,
                one_time_keyboard=True,
                input_field_placeholder="–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤—ã—à–µ"
            )
            
            await message.answer(welcome_text, reply_markup=keyboard)

        @self.router.message(F.contact)
        async def contact_handler(message: Message):
            """Handle contact sharing"""
            contact = message.contact
            phone = self._format_phone(contact.phone_number)
            telegram_id = str(message.from_user.id)
            telegram_username = message.from_user.username
            
            # Save telegram_id mapping to Redis
            telegram_data = {
                "telegram_id": telegram_id,
                "telegram_username": telegram_username,
                "first_name": message.from_user.first_name,
                "last_name": message.from_user.last_name
            }
            
            # Store for 24 hours
            redis_service.set_with_ttl(f"telegram:{phone}", telegram_data, 86400)
            
            success_text = (
                f"‚úÖ –û—Ç–ª–∏—á–Ω–æ! –ù–æ–º–µ—Ä {phone} —Å–≤—è–∑–∞–Ω —Å –±–æ—Ç–æ–º\n\n"
                "üîê –¢–µ–ø–µ—Ä—å –≤—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å –∫–æ–¥—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤ —ç—Ç–æ—Ç —á–∞—Ç\n"
                "üì¶ –ê —Ç–∞–∫–∂–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–∫–∞–∑–∞—Ö\n\n"
                "–ú–æ–∂–µ—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–∞–π—Ç–µ!"
            )
            
            # –£–¥–∞–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞
            await message.answer(success_text, reply_markup=ReplyKeyboardRemove())
            logger.info(f"Phone {phone} linked to Telegram user {telegram_id}")

        @self.router.message(Command("help"))
        async def help_handler(message: Message):
            """Handle /help command"""
            help_text = (
                "üÜò **–ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞**\n\n"
                "**–ö–æ–º–∞–Ω–¥—ã:**\n"
                "/start - –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é\n"
                "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
                "/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–π –Ω–æ–º–µ—Ä\n\n"
                "**–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:**\n"
                "1Ô∏è‚É£ –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –∫–æ–Ω—Ç–∞–∫—Ç–æ–º —á–µ—Ä–µ–∑ /start\n"
                "2Ô∏è‚É£ –ù–∞ —Å–∞–π—Ç–µ –Ω–∞–∂–º–∏—Ç–µ ¬´–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥¬ª\n" 
                "3Ô∏è‚É£ –ö–æ–¥ –ø—Ä–∏–¥–µ—Ç –≤ —ç—Ç–æ—Ç —á–∞—Ç\n\n"
                "**–ß—Ç–æ –µ—â–µ —É–º–µ–µ—Ç –±–æ—Ç:**\n"
                "üì¶ –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –∑–∞–∫–∞–∑–∞—Ö"
            )
            
            await message.answer(help_text, parse_mode="Markdown")

        @self.router.message(Command("status"))
        async def status_handler(message: Message):
            """Handle /status command - check if phone is linked"""
            telegram_id = str(message.from_user.id)
            
            # Search for linked phone numbers
            phone_keys = redis_service.redis.keys("telegram:+7*")
            linked_phone = None
            
            for key in phone_keys:
                data = redis_service.get(key.decode())
                if data and data.get("telegram_id") == telegram_id:
                    linked_phone = key.decode().replace("telegram:", "")
                    break
            
            if linked_phone:
                await message.answer(
                    f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –Ω–æ–º–µ—Ä: {linked_phone}\n\n"
                    "üîê –ö–æ–¥—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: –∞–∫—Ç–∏–≤–Ω–æ\n"
                    "üì¶ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–∫–∞–∑–∞—Ö: –∞–∫—Ç–∏–≤–Ω–æ"
                )
            else:
                await message.answer(
                    "‚ùå –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω\n\n"
                    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –±–æ—Ç—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–¥–æ–≤"
                )

        @self.router.message()
        async def general_handler(message: Message):
            """Handle all other messages"""
            text = message.text or ""
            
            # Try to extract phone number for backward compatibility
            phone = self._extract_phone_number(text)
            
            if phone:
                telegram_id = str(message.from_user.id)
                telegram_username = message.from_user.username
                
                # Save telegram_id mapping to Redis
                telegram_data = {
                    "telegram_id": telegram_id,
                    "telegram_username": telegram_username,
                    "first_name": message.from_user.first_name,
                    "last_name": message.from_user.last_name
                }
                
                # Store for 24 hours
                redis_service.set_with_ttl(f"telegram:{phone}", telegram_data, 86400)
                
                success_text = (
                    f"‚úÖ –ù–æ–º–µ—Ä {phone} –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–æ—Ç—É!\n\n"
                    "üîê –ö–æ–¥—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≤ —ç—Ç–æ—Ç —á–∞—Ç\n"
                    "üì¶ –ü–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –∑–∞–∫–∞–∑–∞—Ö\n\n"
                    "–¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–∞–π—Ç–µ!"
                )
                
                await message.answer(success_text, reply_markup=ReplyKeyboardRemove())
                logger.info(f"Phone {phone} linked to Telegram user {telegram_id}")
            else:
                # –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É –∫–æ–Ω—Ç–∞–∫—Ç–∞
                await message.answer(
                    "üëã –î–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /start\n"
                    "–∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –∫–æ–Ω—Ç–∞–∫—Ç–æ–º —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É!\n\n"
                    "–≠—Ç–æ –±—ã—Å—Ç—Ä–µ–µ –∏ —É–¥–æ–±–Ω–µ–µ üòä"
                )
    
    def _format_phone(self, phone: str) -> str:
        """Format phone number to +7XXXXXXXXXX format"""
        # Remove all non-digit characters
        digits = ''.join(filter(str.isdigit, phone))
        
        # Ensure it starts with 7 and has 11 digits total
        if len(digits) == 11 and digits.startswith('7'):
            return f"+{digits}"
        elif len(digits) == 10:
            return f"+7{digits}"
        elif len(digits) == 11 and digits.startswith('8'):
            return f"+7{digits[1:]}"
        
        return phone  # Return as-is if format is unexpected

    def _extract_phone_number(self, text: str) -> Optional[str]:
        """Extract and normalize phone number from text"""
        if not text:
            return None
        
        # Remove all non-digit characters
        digits = ''.join(filter(str.isdigit, text))
        
        # Check Kazakhstan phone formats
        if len(digits) == 11 and digits.startswith('7'):
            # Format: 7XXXXXXXXXX
            return f"+{digits}"
        elif len(digits) == 10:
            # Format: XXXXXXXXXX (without country code)
            return f"+7{digits}"
        elif len(digits) == 11 and digits.startswith('8'):
            # Format: 8XXXXXXXXXX (replace 8 with +7)
            return f"+7{digits[1:]}"
        
        return None

    async def stop(self):
        """Stop bot and cleanup"""
        if self.bot:
            await self.bot.session.close()
            logger.info("Telegram bot stopped")


# Global instance
telegram_service = TelegramService()


# Helper function for async initialization
async def initialize_telegram_bot(token: str = None):
    """Initialize Telegram bot (call from async context)"""
    await telegram_service.initialize(token)